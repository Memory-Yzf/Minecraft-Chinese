{
  "entity_model_features.config.animate_once": "为每个实体设置一次模型动画",
  "entity_model_features.config.animate_once.tooltip": "默认情况下启用\n此设置使实体模型对每个渲染的实体仅进行一次动画处理\n这在游戏中是完全正常的，但是\n 物品栏屏幕中可见的生物可能会奇怪地闪烁\n 特别是如果它代表您已经可以看到的世界中的真实生物",
  "entity_model_features.config.debug": "调试",
  "entity_model_features.config.optifine_fallback_properties": "使用回退 .properties",
  "entity_model_features.config.optifine_fallback_properties.tooltip": "如果启用，当常规 .properties 文件无法找到时，EMF 会尝试加载回退的 .properties 文件\n例如，如果 pig_baby.properties 不存在，pig_baby.jem 会回退使用 pig.properties\nOptiFine 仅支持这些回退，并且实际上不允许每个模型使用单独的文件，例如 pig_baby.properties",
  "entity_model_features.config.show_reload_error_toast": "显示重载错误提示",
  "entity_model_features.config.show_reload_error_toast.tooltip": "如果启用，当资源重载过程中发生错误时，会显示一个提示信息\n这有助于在重载过程中出错时发现问题",
  "entity_model_features.config.load_warn.1": "EMF 遇到加载错误",
  "entity_model_features.config.load_warn.3": "检查日志或 EMF 设置以获取详细信息",
  "entity_model_features.config.load_warn.2": "EMF 可以重新记录这些错误，路径为：models > debug >",
  "entity_model_features.config.load_warn.title": "重新记录所有加载错误",
  "entity_model_features.config.load_warn.title2": "重新记录所有加载错误（带堆栈跟踪）",
  "entity_model_features.config.load_warn.tooltip": "此选项将重新打印上次资源重载过程中遇到的所有 EMF 加载错误，按遇到的顺序输出到日志中\n并非所有这些错误都会很有帮助，因为它们可能缺少周围的日志上下文",
  "entity_model_features.config.optifine_floor": "地板盒子 UV",
  "entity_model_features.config.optifine_floor.tooltip": "OptiFine 会将所有自定义盒子 UV 的值向下取整\n即，它使这些值变成整数。\n启用此设置后，EMF 也会执行相同的操作\nEMF 还会在发现模型没有向下取整的 UV 时记录日志",
  "entity_model_features.config.optifine_syntax": "CEM 动画语法限制",
  "entity_model_features.config.optifine_syntax.tooltip": "如果启用，将强制执行 OptiFine 的 CEM 语法限制，例如\n动画中的骨骼 ID 不能以 _ 或数字开头。\n数字不能以 ‘.’ 开头，例如 ‘.9’\n名为 ‘render’ 的骨骼不能在动画中引用\n启用此设置时，EMF 会记录任何违反这些规则的动画错误并使其无效。",
  "entity_model_features.config.models.explain": "并非这里显示的所有部分都会导出\n只有声明的部分会导出。\n你可以通过在导出后检查游戏日志来查找缺失部分的变换细节。",
  "entity_model_features.config.optifine_subfolders": "子文件夹模型必须变化",
  "entity_model_features.config.optifine_subfolders.tooltip": "在 OptiFine 中，模型文件的子文件夹选项仅在模型有变化时有效。\n例如，‘optifine/cem/skeleton/skeleton.jem’ 只有在有变体时才会加载\n例如 ‘optifine/cem/skeleton/skeleton2.jem’ 或者 .properties 文件\n启用此设置后，EMF 也会强制执行这一点，\n如果 EMF 发现一个没有变化的模型，会记录这个问题", 
  "entity_model_features.config.debug.tooltip": "调试选项，有助于解决一些问题",
  "entity_model_features.config.debug_right_click": "在右击实体时显示 EMF 调试数据",
  "entity_model_features.config.debug_right_click.tooltip": "如果启用，当右击实体时，将在日志和聊天中打印出 EMF 调试信息。",
  "entity_model_features.config.ebe_config_modify": "增强方块实体（EBE）Mod 补丁",
  "entity_model_features.config.ebe_config_modify.tooltip": "如果启用，这将允许 EMF 修改 EBE Mod 的配置\n禁用特定方块实体的 EBE，前提是该方块实体实际加载了自定义的 EMF 模型。\nEMF 之后无法自动重新启用这些设置，\n如果需要，您必须手动重新启用它们。",
  "entity_model_features.config.force_models": "尽量防止 EMF 模型被覆盖",
  "entity_model_features.config.force_models.tooltip": "将尝试强制实体渲染器使用EMF\n设置的模型，这可以覆盖其他模组更改的原版模型\n这不适用于所有模组",
  "entity_model_features.config.function_explanation.abs": "abs(x)\n获取一个数字的绝对值。将负数变为正数",
  "entity_model_features.config.function_explanation.acos": "acos(x)\n获取 x 的反余弦值",
  "entity_model_features.config.function_explanation.asin": "asin(x)\n获取 x 的反正弦值",
  "entity_model_features.config.function_explanation.atan": "atan(x)\n获取 x 的反正切值",
  "entity_model_features.config.function_explanation.atan2": "atan2(y, x)\n获取正 x 轴和点 (x, y) 之间的角度",
  "entity_model_features.config.function_explanation.catmullrom": "catmullrom(k, x, y, z, w)\n使用 Catmull-Rom 插值函数在 x 和 y 之间插值，控制点为 z 和 w",
  "entity_model_features.config.function_explanation.ceil": "ceil(x)\n将 x 向上舍入到最近的整数",
  "entity_model_features.config.function_explanation.clamp": "clamp(x, min, max)\n将数字限制在 min 和 max 之间",
  "entity_model_features.config.function_explanation.cos": "cos(x)\n获取 x 的余弦值",
  "entity_model_features.config.function_explanation.nbt": "nbt(x, y)\n布尔函数，如果实体具有匹配查询 y 的 NBT 标签 x，则返回 true。\nx 等于 NBT 随机属性中的 'nbt.<n>.' 后的内容。\ny 等于 NBT 随机属性中 '=' 后的内容。\n例如，NBT 属性中的 'nbt.1.SleepingX=exists:true' 将在动画函数中表示为 'nbt(SleepingX,exists:true)'",
  "entity_model_features.config.function_explanation.cubicbezier": "cubicbezier(k, x, y, z, w)\n使用三次贝塞尔插值函数在 x 和 y 之间插值，控制点为 z 和 w",
  "entity_model_features.config.function_explanation.degdiff": "degdiff(x, y)\n返回两个角度值 x 和 y 之间的最短角度差",
  "entity_model_features.config.function_explanation.easeinback": "easeinback(k, x, y)\n使用 ease in back 函数在 x 和 y 之间插值\n\n示例见这里: https://easings.net/",
  "entity_model_features.config.function_explanation.easeinbounce": "easeinbounce(k, x, y)\n使用 ease in bounce 函数在 x 和 y 之间插值\n\n示例见这里: https://easings.net/",
  "entity_model_features.config.function_explanation.easeincirc": "easeincirc(k, x, y)\n使用 ease in circ 函数在 x 和 y 之间插值\n\n示例见这里: https://easings.net/",
  "entity_model_features.config.function_explanation.easeincubic": "easeincubic(k, x, y)\n使用 ease in cubic 函数在 x 和 y 之间插值\n\n示例见这里: https://easings.net/",
  "entity_model_features.config.function_explanation.easeinelastic": "easeinelastic(k, x, y)\n使用 ease in elastic 函数在 x 和 y 之间插值\n\n示例见这里: https://easings.net/",
  "entity_model_features.config.function_explanation.easeinexpo": "easeinexpo(k, x, y)\n使用 ease in expo 函数在 x 和 y 之间插值\n\n示例见这里: https://easings.net/",
  "entity_model_features.config.function_explanation.easeinoutback": "easeinoutback(k, x, y)\n使用 ease in 和 ease out back 函数在 x 和 y 之间插值\n\n示例见这里: https://easings.net/",
  "entity_model_features.config.function_explanation.easeinoutbounce": "easeinoutbounce(k, x, y)\n使用 ease in 和 ease out bounce 函数在 x 和 y 之间插值\n\n示例见这里: https://easings.net/",
  "entity_model_features.config.function_explanation.easeinoutcirc": "easeinoutcirc(k, x, y)\n使用 ease in 和 ease out circ 函数在 x 和 y 之间插值\n\n示例见这里: https://easings.net/",
  "entity_model_features.config.function_explanation.easeinoutcubic": "easeinoutcubic(k, x, y)\n使用 ease in 和 ease out cubic 函数在 x 和 y 之间插值\n\n示例见这里: https://easings.net/",
  "entity_model_features.config.function_explanation.easeinoutelastic": "easeinoutelastic(k, x, y)\n使用 ease in 和 ease out elastic 函数在 x 和 y 之间插值\n\n示例见这里: https://easings.net/",
  "entity_model_features.config.function_explanation.easeinoutexpo": "easeinoutexpo(k, x, y)\n使用 ease in 和 ease out expo 函数在 x 和 y 之间插值\n\n示例见这里: https://easings.net/",
  "entity_model_features.config.function_explanation.easeinoutquad": "easeinoutquad(k, x, y)\n使用 ease in 和 ease out quad 函数在 x 和 y 之间插值\n\n示例见这里: https://easings.net/",
  "entity_model_features.config.function_explanation.easeinoutquart": "easeinoutquart(k, x, y)\n使用 ease in 和 ease out quart 函数在 x 和 y 之间插值\n\n示例见这里: https://easings.net/",
  "entity_model_features.config.function_explanation.easeinoutquint": "easeinoutquint(k, x, y)\n使用 ease in 和 ease out quint 函数在 x 和 y 之间插值\n\n示例见这里: https://easings.net/",
  "entity_model_features.config.function_explanation.easeinoutsine": "easeinoutsine(k, x, y)\n使用 ease in 和 ease out sine 函数在 x 和 y 之间插值\n\n示例见这里: https://easings.net/",
  "entity_model_features.config.function_explanation.easeinquad": "easeinquad(k, x, y)\n使用 ease in quad 函数在 x 和 y 之间插值\n\n示例见这里: https://easings.net/",
  "entity_model_features.config.function_explanation.easeinquart": "easeinquart(k, x, y)\n使用 ease in quart 函数在 x 和 y 之间插值\n\n示例见这里: https://easings.net/",
  "entity_model_features.config.function_explanation.easeinquint": "easeinquint(k, x, y)\n使用 ease in quint 函数在 x 和 y 之间插值\n\n示例见这里: https://easings.net/",
  "entity_model_features.config.function_explanation.easeinsine": "easeinsine(k, x, y)\n使用 ease in sine 函数在 x 和 y 之间插值\n\n示例见这里: https://easings.net/",
  "entity_model_features.config.function_explanation.easeoutback": "easeoutback(k, x, y)\n使用 ease out back 函数在 x 和 y 之间插值\n\n示例见这里: https://easings.net/",
  "entity_model_features.config.function_explanation.easeoutbounce": "easeoutbounce(k, x, y)\n使用 ease out bounce 函数在 x 和 y 之间插值\n\n示例见这里: https://easings.net/",
  "entity_model_features.config.function_explanation.easeoutcirc": "easeoutcirc(k, x, y)\n使用 ease out circ 函数在 x 和 y 之间插值\n\n示例见这里: https://easings.net/",
  "entity_model_features.config.function_explanation.easeoutcubic": "easeoutcubic(k, x, y)\n使用 ease out cubic 函数在 x 和 y 之间插值\n\n示例见这里: https://easings.net/",
  "entity_model_features.config.function_explanation.easeoutelastic": "easeoutelastic(k, x, y)\n使用 ease out elastic 函数在 x 和 y 之间插值\n\n示例见这里: https://easings.net/",
  "entity_model_features.config.function_explanation.easeoutexpo": "easeoutexpo(k, x, y)\n使用 ease out expo 函数在 x 和 y 之间插值\n\n示例见这里: https://easings.net/",
  "entity_model_features.config.function_explanation.easeoutquad": "easeoutquad(k, x, y)\n使用 ease out quad 函数在 x 和 y 之间插值\n\n示例见这里: https://easings.net/",
  "entity_model_features.config.function_explanation.easeoutquart": "easeoutquart(k, x, y)\n使用 ease out quart 函数在 x 和 y 之间插值\n\n示例见这里: https://easings.net/",
  "entity_model_features.config.function_explanation.easeoutquint": "easeoutquint(k, x, y)\n使用 ease out quint 函数在 x 和 y 之间插值\n\n示例见这里: https://easings.net/",
  "entity_model_features.config.function_explanation.easeoutsine": "easeoutsine(k, x, y)\n使用 ease out sine 函数在 x 和 y 之间插值\n\n示例见这里: https://easings.net/",
  "entity_model_features.config.function_explanation.exp": "exp(x)\n获取 e（欧拉常数）提升到 x 的幂",
  "entity_model_features.config.function_explanation.floor": "floor(x)\n将 x 向下舍入到最接近的整数",
  "entity_model_features.config.function_explanation.fmod": "fmod(x, y)\n类似于 % 运算符，但返回的值始终具有与除数相同的符号",
  "entity_model_features.config.function_explanation.frac": "frac(x)\n获取 x 的小数部分（小数点后的部分）",
  "entity_model_features.config.function_explanation.hermite": "hermite(k, x, y, z, w)\n使用 hermite 样条函数在 x 和 y 之间插值，并使用控制点 z 和 w",
  "entity_model_features.config.function_explanation.if": "if(cond, val, [cond2, val2, ...], val_else)\n基于一个或多个条件选择一个值",
  "entity_model_features.config.function_explanation.keyframe": "keyframe(k, a, b, c,...)\n基于当前帧 k 和关键帧在值之间平滑插值。'a' 是 'k=0'，'b' 是 'k=1'，'c' 是 'k=2' 等等。",
  "entity_model_features.config.function_explanation.keyframeloop": "keyframeloop(k, a, b, c,...)\n基于当前帧 k 和关键帧在值之间平滑插值。'a' 是 'k=0'，'b' 是 'k=1'，'c' 是 'k=2' 等等，但当 k 超过关键帧数量时，动画会循环回到帧 'a'",
  "entity_model_features.config.function_explanation.lerp": "lerp(k, x, y)\n在 X 和 Y 之间进行线性插值",
  "entity_model_features.config.function_explanation.log": "log(x)\n获取 x 的自然对数",
  "entity_model_features.config.function_explanation.max": "max(x, y, ...)\n从一组数字中获取最大值",
  "entity_model_features.config.function_explanation.min": "min(x, y, ...)\n从一组数字中获取最小值",
  "entity_model_features.config.function_explanation.pow": "pow(x, y)\n获取 x 提升到 y 的幂",
  "entity_model_features.config.function_explanation.print": "print(id, n, x)\n每隔第 N 帧打印值 \"x\"",
  "entity_model_features.config.function_explanation.printb": "printb(id, n, x)\n每隔第 N 帧打印布尔值 \"x\"",
  "entity_model_features.config.function_explanation.quadbezier": "quadbezier(k, x, y, z)\n使用二次贝塞尔样条函数，在 x 和 y 之间插值，控制点为 z",
  "entity_model_features.config.function_explanation.raddiff": "raddiff(x, y)\n返回两个弧度值 x 和 y 之间的最短角度弧度差",
  "entity_model_features.config.function_explanation.random": "random(seed)\n返回从 0 到 1 的随机数。提供一个种子将始终返回相同的结果，种子是可选的",
  "entity_model_features.config.function_explanation.round": "round(x)\n将 x 四舍五入到最接近的整数",
  "entity_model_features.config.function_explanation.signum": "signum(x)\n获取 x 的符号（正数或负数）",
  "entity_model_features.config.function_explanation.sin": "sin(x)\n获取 x 的正弦值",
  "entity_model_features.config.function_explanation.between": "between(x, min, max)\n检查一个值是否在最小值和最大值之间",
  "entity_model_features.config.function_explanation.equals": "equals(x, y, epsilon)\n比较两个浮动值，允许误差范围",
  "entity_model_features.config.function_explanation.in": "in(x, val1, val2, ...)\n检查一个值是否等于多个值之一",
  "entity_model_features.config.function_explanation.sqrt": "sqrt(x)\n获取 x 的平方根",
  "entity_model_features.config.function_explanation.tan": "tan(x)\n获取 x 的正切值",
  "entity_model_features.config.function_explanation.ifb": "if(cond, val, [cond2, val2, ...], val_else)\n基于一个或多个条件选择一个值\n仅返回布尔值",
  "entity_model_features.config.function_explanation.randomb": "random(seed)\n返回随机布尔值 true|false。提供一个种子将始终返回相同的结果，种子是可选的",
  "entity_model_features.config.function_explanation.catch": "catch(x, c, id)\n返回 x，如果 x 为 NaN 或者导致其他动画错误，则返回 c。\n如果添加 id，catch 函数将把使用 c 的原因打印到游戏日志中\n主要用于动画调试，如果有可能触发此错误，你应该修复那个问题。",
  "entity_model_features.config.function_explanation.todeg": "todeg(rad)\n将弧度转换为角度",
  "entity_model_features.config.function_explanation.torad": "torad(deg)\n将角度转换为弧度",
  "entity_model_features.config.function_explanation.wrapdeg": "wrapdeg(x)\n将角度值 x 包裹到 -180 到 180 之间",
  "entity_model_features.config.function_explanation.wraprad": "wraprad(x)\n将弧度值 x 包裹到 -pi 到 pi 之间",
  "entity_model_features.config.general": "常规",
  "entity_model_features.config.general.tooltip": "常规设置",
  "entity_model_features.config.large_mob_lod": "保持大型怪物的 LOD",
  "entity_model_features.config.large_mob_lod.tooltip": "如果启用此选项，它将根据怪物的大小减少上述设置的细节等级（LOD）影响。\n较大的怪物将比小型怪物具有更不明显的跳帧现象",
  "entity_model_features.config.lod": "动画 LOD 距离",
  "entity_model_features.config.lod.tooltip": "设置动画开始跳帧的距离，降低细节等级（LOD），这有助于提高性能。\nNone = 不跳帧\n16 = 每隔 16 格与玩家的距离将跳过 1 帧\n较小的数字意味着更多的跳帧和更大的性能提升\n但当然，动画会变得更加明显地低帧率，特别是 LOD 距离设置较近时",
  "entity_model_features.config.log_math": "记录动画计算",
  "entity_model_features.config.log_math.tooltip": "将动画计算调试数据打印到日志中\n警告：会导致极大的滞后！",
  "entity_model_features.config.log_models": "记录模型构建信息",
  "entity_model_features.config.log_models.tooltip": "打印模型的创建调试数据到日志中",
  "entity_model_features.config.low_fps_lod": "在低帧率下保留 LOD",
  "entity_model_features.config.low_fps_lod.tooltip": "如果启用，此设置将根据你的帧率减少上述设置对细节等级（LOD）的影响。\n仅在帧率低于 60 时适用，因为在较低帧率下跳帧变得更加明显。",
  "entity_model_features.config.optimizations": "优化",
  "entity_model_features.config.optimizations.tooltip": "动画优化的相关设置",
  "entity_model_features.config.options": "选项和修复",
  "entity_model_features.config.options.tooltip": "基本功能或模组兼容性修复的各种选项",
  "entity_model_features.config.performance": "性能设置",
  "entity_model_features.config.physics": "Physics 模组补丁 #2",
  "entity_model_features.config.physics.1": "使用原版模型",
  "entity_model_features.config.physics.2": "使用EMF（CEM） 模型",
  "entity_model_features.config.physics.tooltip": "如果启用了 Physics 模组，则只会在死亡时渲染原始的原版模型零件\n这部分有效，但不是一个完美的解决方案",
  "entity_model_features.config.print_mode": "导出模型",
  "entity_model_features.config.print_mode.all_log": "所有模型 - 仅日志",
  "entity_model_features.config.print_mode.all_log_jem": "所有模型 - 日志 \u0026 .jem",
  "entity_model_features.config.print_mode.log": "未知模型 - 仅日志",
  "entity_model_features.config.print_mode.log_jem": "未知模型 - 日志 \u0026 .jem",
  "entity_model_features.config.print_mode.tooltip": "这将打印出每个 EMF 可以访问的模型的部件信息或完整的 .jem 文件，每次重新加载时都会执行！\n重新加载后，.jem 文件可以在 \"MC_DIRECTORY/emf/export\" 中找到。\n这些 .jem 文件是 Blockbench 可用的，包含正确的枢轴框和 UV 坐标。\n未知模型是指不被 OptiFine CEM 支持的模型。",
  "entity_model_features.config.debug_hover": "仅在悬停时调试渲染",
  "entity_model_features.config.debug_hover.tooltip": "使上面的渲染设置仅适用于客户端悬停在其上的实体。\n即直接被你观察到的实体。",
  "entity_model_features.config.render": "如何呈现自定义模型部件",
  "entity_model_features.config.render.green": "闪光绿色",
  "entity_model_features.config.render.lines": "概述",
  "entity_model_features.config.render.lines_texture": "网格线覆盖纹理",
  "entity_model_features.config.render.lines_texture_flash": "网格线闪烁覆盖纹理",
  "entity_model_features.config.render.none": "已禁用",
  "entity_model_features.config.render.normal": "正常",
  "entity_model_features.config.render.tooltip": "更改自定义模型零件的渲染方式，这不会影响原版模型零件。\n正常 \u003d 正常渲染\n绿色闪烁 \u003d 自定义零件将闪烁绿色\n轮廓 \u003d 模型零件的轮廓将呈现\n禁用 \u003d 自定义模型零件将不渲染",
  "entity_model_features.config.substitute_vanilla": "替换丢失的模型部分",
  "entity_model_features.config.substitute_vanilla.tooltip": "EMF将尝试用原版文件替换 .jem\n 模型文件中缺失的部分",
  "entity_model_features.config.texture_override_mode": "子模型纹理处理",
  "entity_model_features.config.texture_override_mode.dont": "忽略纹理覆盖",
  "entity_model_features.config.texture_override_mode.emf": "尝试使用 EMF 代码",
  "entity_model_features.config.texture_override_mode.iris": "先尝试使用 Iris",
  "entity_model_features.config.texture_override_mode.tooltip": "这将控制 EMF 如何处理具有覆盖纹理集的渲染子模型\n例如，如果爬行者模型具有头部子模型的单独纹理\n有两种方法可以做到这一点，依靠我的代码，或者依靠 Iris mod 的怪癖\n我的代码“有效”，但我不是渲染缓冲区的专家，这可能会导致问题\nIris 怪癖使用非常简单且看似安全/稳定的方法方法，但我被告知它不是预期的 Iris 行为\n如果未安装 Iris，Iris 选项将默认为 EMF 代码\n这几乎总是应该保持默认值，除非在子模型中调试纹理覆盖",
  "entity_model_features.config.tools": "工具",
  "entity_model_features.config.tools.tooltip": "帮助模型制作或区分自定义模型的可选工具",
  "entity_model_features.config.update": "模型更新频率",
  "entity_model_features.config.update.tooltip": "设置生物模型更新的频率，用于如健康值和年龄等变化。\nNever = 从不更新\nSlow = 3-5 秒\nAverage = 大约 1 秒\nFast = 少于 1 秒\nInstant = 即时更新（大量生物时可能会有延迟）",
  "entity_model_features.config.vanilla_render": "显示原版模型模式",
  "entity_model_features.config.vanilla_render.normal": "普通",
  "entity_model_features.config.vanilla_render.offset": "偏移",
  "entity_model_features.config.vanilla_render.tooltip": "尝试将原版模型与自定义模型一起渲染以进行比较\n它不会有动画，因此一些位置可能会有些奇怪。",
  "entity_model_features.config.variable_explanation.age": "年龄（以刻为单位）",
  "entity_model_features.config.variable_explanation.is_swinging_right_arm": "如果实体正在挥动右臂，则为真。注意，false 并不意味着左臂在挥动",
  "entity_model_features.config.variable_explanation.is_swinging_left_arm": "如果实体正在挥动左臂，则为真。注意，false 并不意味着右臂在挥动",
  "entity_model_features.config.variable_explanation.anger_time": "实体剩余的愤怒时间（以刻为单位）。在攻击状态下为 400-780，然后在目标失去后倒计时到 0",
  "entity_model_features.config.variable_explanation.anger_time_start": "愤怒时间的初始值",
  "entity_model_features.config.variable_explanation.day_count": "当前的天数",
  "entity_model_features.config.variable_explanation.day_time": "当前的白昼时间（以刻为单位，范围 0-24000）",
  "entity_model_features.config.variable_explanation.death_time": "实体死亡的时间。计时从 0 开始，最多到 20",
  "entity_model_features.config.variable_explanation.dimension": "当前的维度。主世界：0，地狱：-1，末地：1",
  "entity_model_features.config.variable_explanation.distance": "实体与客户端玩家之间的距离（以方块为单位）\n\n虽然添加了距离变量以方便使用，但也可以通过以下代码在 OptiFine 中实现相同功能：\n\"var.distance\": \"sqrt(pow(pos_x - player_pos_x, 2) + pow(pos_y - player_pos_y, 2) + pow(pos_z - player_pos_z, 2))\"",
  "entity_model_features.config.variable_explanation.e": "欧拉数\n2.718281.....",
  "entity_model_features.config.variable_explanation.entity_variable": "实体变量的格式为 \"var.<name>\"（浮动型）或 \"varb.<name>\"（布尔型）\n\n名称可以是任何字符串，例如 \"var.xyz\"，\"var.last_rx\" 等等。\n\n变量附加到渲染的实体上，默认值为 0 或 false。\n\n实体变量对于存储帧间的动画数据非常有用。",
  "entity_model_features.config.variable_explanation.entity_variable.title": "实体变量",
  "entity_model_features.config.variable_explanation.false": "常量值\nfalse",
  "entity_model_features.config.variable_explanation.fluid_depth": "淹没实体上下方的液体深度，如果未被淹没，则为 0",
  "entity_model_features.config.variable_explanation.fluid_depth_down": "淹没实体下方的液体深度，如果未被淹没，则为 0",
  "entity_model_features.config.variable_explanation.fluid_depth_up": "淹没实体上方的液体深度，如果未被淹没，则为 0",
  "entity_model_features.config.variable_explanation.frame_time": "自上一帧以来的时间（秒）",
  "entity_model_features.config.variable_explanation.head_pitch": "头部俯仰（x 轴旋转）",
  "entity_model_features.config.variable_explanation.head_yaw": "头部偏航（y 轴旋转）",
  "entity_model_features.config.variable_explanation.health": "实体当前的生命值",
  "entity_model_features.config.variable_explanation.height_above_ground": "实体距离地面的高度\n地面是指实体下方最高的可碰撞方块",
  "entity_model_features.config.variable_explanation.hurt_time": "实体受伤的持续时间。从 10 倒计时至 0",
  "entity_model_features.config.variable_explanation.id": "实体的唯一数值标识符\n对于相同实体始终相同",
  "entity_model_features.config.variable_explanation.is_aggressive": "实体是否对玩家或其他实体具有攻击性",
  "entity_model_features.config.variable_explanation.is_alive": "实体是否处于生存状态",
  "entity_model_features.config.variable_explanation.is_blocking": "实体是否正在用盾牌进行格挡",
  "entity_model_features.config.variable_explanation.is_burning": "实体是否在燃烧",
  "entity_model_features.config.variable_explanation.is_child": "实体是否处于婴儿状态",
  "entity_model_features.config.variable_explanation.is_climbing": "实体是否正在攀爬可攀爬的方块，或是蜘蛛在墙上",
  "entity_model_features.config.variable_explanation.is_crawling": "实体是否正在爬行",
  "entity_model_features.config.variable_explanation.is_glowing": "实体是否具有发光效果",
  "entity_model_features.config.variable_explanation.is_hurt": "实体是否正在受到伤害",
  "entity_model_features.config.variable_explanation.frame_counter": "当前帧的索引（从 0 到 720719，然后重置为 0）",
  "entity_model_features.config.variable_explanation.is_in_ground": "三叉戟是否被插入地面",
  "entity_model_features.config.variable_explanation.is_in_gui": "实体是否在 GUI 界面内",
  "entity_model_features.config.variable_explanation.is_in_hand": "实体是否被持在手中",
  "entity_model_features.config.variable_explanation.is_in_item_frame": "实体是否在物品框架中",
  "entity_model_features.config.variable_explanation.is_in_lava": "实体是否接触到熔岩",
  "entity_model_features.config.variable_explanation.is_in_water": "实体是否接触到水",
  "entity_model_features.config.variable_explanation.is_invisible": "实体是否具有隐形效果/NBT 标签",
  "entity_model_features.config.variable_explanation.is_on_ground": "实体是否接触到地面",
  "entity_model_features.config.variable_explanation.is_on_head": "实体是否被戴在另一个实体的头上",
  "entity_model_features.config.variable_explanation.is_on_shoulder": "鹦鹉是否坐在你的肩膀上",
  "entity_model_features.config.variable_explanation.is_ridden": "实体是否被其他实体骑乘",
  "entity_model_features.config.variable_explanation.is_riding": "实体是否正在骑乘另一个实体",
  "entity_model_features.config.variable_explanation.is_sitting": "猫/狼/鹦鹉是否坐着",
  "entity_model_features.config.variable_explanation.is_sneaking": "猫/雪豹是否正在潜行",
  "entity_model_features.config.variable_explanation.is_jumping": "一个生物是否正在跳跃",
  "entity_model_features.config.variable_explanation.is_sprinting": "猫/雪豹是否正在冲刺",
  "entity_model_features.config.variable_explanation.is_tamed": "猫/狼/鹦鹉是否已被驯服",
  "entity_model_features.config.variable_explanation.is_wet": "实体是否在水中/雨中",
  "entity_model_features.config.variable_explanation.is_right_handed": "玩家是否为右撇子",
  "entity_model_features.config.variable_explanation.is_swimming": "实体是否在游泳",
  "entity_model_features.config.variable_explanation.is_gliding": "实体是否在滑行",
  "entity_model_features.config.variable_explanation.is_first_person_hand": "游戏是否正在渲染第一人称的手",
  "entity_model_features.config.variable_explanation.limb_speed": "四肢运动速度。范围从 0 到 1（静止 = 0，冲刺 = 1）",
  "entity_model_features.config.variable_explanation.limb_swing": "四肢动画计数器。当实体移动时按时间滴答计数",
  "entity_model_features.config.variable_explanation.max_health": "实体的最大生命值",
  "entity_model_features.config.variable_explanation.model_part": "模型变量的格式为：\n \"<model>.<variable_name>\"\n\n模型可以是：\n \"this\" - 当前的自定义模型\n \"part\" - 附加自定义模型的原始部件模型\n \"<part>\" - 按部件名称的原始模型\n \"<id>\" - 按 ID 的自定义模型\n \"<part>:<sub_id>:<sub_sub_id>:...\" - (分层) 从原始部件名称开始，之后按 ID 查找子部件\n \"<id>:<sub_id>:<sub_sub_id>:...\" - (分层) 从 ID 模型开始，之后按 ID 查找子部件\n\n如果有重复项，使用按部件名称或 ID 找到的第一个模型。\n按 ID 的模型查找是深度的，分层指定时也适用。\n\n分层指定允许模型组（JSON 部件模型）在不同部件之间重用。\n例如，一个手部模型（\"shoulder:upper_arm:elbow:forearm:palm:finger[1.5]\"）可以同时用于左右手。动画可以使用 \"left_hand:finger1\" 作为左大拇指和 \"right_hand:finger1\" 作为右大拇指。\n分层指定中的中间父项可以跳过。\n\n变量名：\n tx, ty, tz - 平移 x, y, z\n rx, ry, rz - 旋转 x, y, z\n sx, sy, sz - 缩放 x, y, z\n visible - 显示模型和子模型（布尔值）\n visible_boxes - 仅显示模型，不影响子模型（布尔值）",
  "entity_model_features.config.variable_explanation.model_part.title": "模型部件变量",
  "entity_model_features.config.variable_explanation.move_forward": "实体当前朝向的前进移动。范围从 -1 到 1，表示玩家当前运动向量的单位圆在 Y 轴上的截距。1 表示前进，-1 表示后退",
  "entity_model_features.config.variable_explanation.move_strafing": "实体当前在其朝向的右侧 90 度方向上的移动。范围从 -1 到 1，表示玩家当前运动向量的单位圆在 X 轴上的截距",
  "entity_model_features.config.variable_explanation.nan": "不是一个数字\n在运行时抛出异常\n用于调试",
  "entity_model_features.config.variable_explanation.pi": "常量值\n3.1415926",
  "entity_model_features.config.variable_explanation.is_using_item": "实体是否正在使用物品，例如玩家右键点击桶",
  "entity_model_features.config.variable_explanation.is_holding_item_right": "实体的右手槽中是否持有物品",
  "entity_model_features.config.variable_explanation.is_holding_item_left": "实体的左手槽中是否持有物品",
  "entity_model_features.config.variable_explanation.player_pos": "客户端玩家当前的世界位置",
  "entity_model_features.config.variable_explanation.player_rot": "客户端玩家当前的世界旋转。北方为 0",
  "entity_model_features.config.variable_explanation.pos": "实体当前的世界位置",
  "entity_model_features.config.variable_explanation.render_variable": "渲染变量\n render.shadow_size\n - 实体下方阴影的大小\n render.shadow_opacity\n - 阴影的透明度\n render.shadow_offset_x, render.shadow_offset_z\n - 阴影的位置\n render.leash_offset_x, render.leash_offset_y, render.leash_offset_z\n - 拴绳连接点的位置",
  "entity_model_features.config.variable_explanation.render_variable.title": "渲染变量",
  "entity_model_features.config.variable_explanation.rot": "实体当前的世界旋转。北方为 0",
  "entity_model_features.config.variable_explanation.rule_index": "当前匹配随机模型规则的索引。默认为 0",
  "entity_model_features.config.variable_explanation.swing_progress": "实体攻击的进度。范围从 0 到 1",
  "entity_model_features.config.variable_explanation.time": "总游戏时间（以刻为单位，与日光周期无关）",
  "entity_model_features.config.variable_explanation.true": "常量值\ntrue",
  "entity_model_features.config.models": "所有模型",
  "entity_model_features.config.models.enabled": "启用模型",
  "entity_model_features.config.models.enabled.tooltip": "设置是否加载给定的 .jem 模型文件",
  "entity_model_features.config.models.part_names": "此模型的部件名称",
  "entity_model_features.config.models.export": "导出模型为 .jem 文件",
  "entity_model_features.config.models.export.tooltip": "将此模型导出为 .jem 文件到目录 \"MC_DIRECTORY/emf/export\"\n该文件可以在 Blockbench 中打开，包含所有自定义模型所需的数据\n包括枢轴点、框体和 UV\n额外的数据也会在日志中打印，告诉你将此 .jem 文件放置在哪个位置以便在资源包中使用。",
  "entity_model_features.config.models.export.success": "模型导出成功",
  "entity_model_features.config.models.export.fail": "模型无法导出，因为：",
  "entity_model_features.config.models.arrows": "arrow.jem 和 spectral_arrow.jem 不会出现在这里，但都被支持",
  "entity_model_features.config.models.cape": "\nplayer_cape.jem 不会出现在这里，但也被支持，它是 player.jem 的精确副本，但仅包含 '披风' 部分",
  "entity_model_features.config.variables": "变量",
  "entity_model_features.config.functions": "函数",
  "entity_model_features.config.player_settings": "玩家设置",
  "entity_model_features.config.only_client": "仅修改你的玩家模型",
  "entity_model_features.config.only_client.tooltip": "如果启用，这将仅应用自定义玩家模型到你自己的玩家\n忽略多人游戏中的其他玩家",
  "entity_model_features.config.math": "动画数学细节",
  "entity_model_features.config.math.explain": "本部分提供了 EMF 自定义实体模型动画中可用的数学函数和变量的详细信息。\n包括从其他使用其 API 的模组添加到 EMF 的内容。\n每个函数和变量在点击时将提供更多细节。",
  "entity_model_features.config.variables.explain": "列出了当前注册用于 EMF 自定义实体模型动画的所有数学变量。\n点击时每个变量将提供更多细节。",
  "entity_model_features.config.functions.explain": "列出了当前注册用于 EMF 自定义实体模型动画的所有数学函数。\n点击时每个函数将提供更多细节。",
  "entity_model_features.title": "实体模型功能",
  "entity_model_features.suffix_property": "模型后缀（可选）\n匹配实体模型设置的最后一个随机模型后缀号\n默认为 0\n示例：modelSuffix.1= 2 4 6\n§amodelSuffix.<n>=<list>",
  "entity_model_features.rule_property": "模型规则（可选）\n匹配实体模型与之匹配的最后一个随机模型规则号\n默认为 0\n示例：modelRule.1= 2 4 6\n§amodelRule.<n>=<list>",
  "entity_model_features.var_property": "实体变量浮动（可选）\n匹配实体的 CEM 动画变量值\n默认为 0\n示例：（对于动画变量 'var.xyz'） var.1.xyz= 2 4 6\n§avar.<n>.<variable>=<list>",
  "entity_model_features.varb_property": "实体变量布尔值（可选）\n匹配实体的 CEM 动画变量值\n默认为 false\n示例：（对于动画变量 'varb.xyz'） varb.1.xyz=true\n§avarb.<n>.<variable>=<true|false>",
  "entity_model_features.global_var_property": "全局变量浮动（可选）\n匹配 CEM 动画全局变量值\n默认为 0\n示例：（对于动画变量 'global_var.xyz'） global_var.1.xyz= 2 4 6\n§aglobal_var.<n>.<variable>=<list>",
  "entity_model_features.global_varb_property": "全局变量布尔值（可选）\n匹配 CEM 动画全局变量值\n默认为 false\n示例：（对于动画变量 'global_varb.xyz'） global_varb.1.xyz=true\n§aglobal_varb.<n>.<variable>=<true|false>",
  "entity_model_features.config.variable_explanation.global_variable": "全局变量的格式为 \"global_var.<name>\"（浮动）或 \"global_varb.<name>\"（布尔值）\n名称可以是任何字符串，例如 \"global_var.xyz\"、\"global_var.last_rx\" 等。\n变量是全局保存的，默认为 0 或 false。\n全局变量对于存储多个实体使用的动画数据非常有用。",
  "entity_model_features.config.variable_explanation.global_variable.title": "全局变量",
  "entity_model_features.config.variable_explanation.optifine_parts": "OptiFine 部件名称：",
  "entity_model_features.config.variable_explanation.unknown_parts": "未映射的部件名称：",
  "entity_model_features.config.prevent_hand": "防止第一人称手部动画",
  "entity_model_features.config.reset_player": "每次渲染重置玩家模型",
  "entity_model_features.config.reset_player.tooltip": "这会让 EMF 在每次渲染之前重置玩家模型的所有原始部件变换。\n仅在玩家有自定义模型时应用。\n这不是典型的行为，但由于许多模组会更改玩家动画，\n这个设置大大减少了模组和动画包之间的玩家动画兼容性难度。\n例如：玩家表情模组。\n这种兼容性仍然需要包制作方的工作。",
  "entity_model_features.config.models.file_names": "文件名 & 位置",
  "entity_model_features.config.prevent_hand.tooltip": "如果启用，这将强制禁止所有自定义 EMF 动画在第一人称手部模型上播放",
  "entity_model_features.config.models_text": "这些是通过 EMF 可修改的所有模型\n这些屏幕将仅显示 / 导出有关这些模型未修改状态的信息\n如果你想查看模型的当前状态，你需要在游戏中查看该模型",
  "entity_model_features.config.ebe_warn.1": "某些 EBE 模组选项已被 EMF 强制禁用",
  "entity_model_features.config.ebe_warn.2": "这是因为资源包正在加载该方块实体的自定义模型",
  "entity_model_features.config.ebe_warn.3": "目前禁用的选项：",
  "entity_model_features.config.ebe_warn.4": "可以在 EMF 的模型设置中更改此选项",
  "entity_model_features.config.variation_base": "要求基础模型用于变体",
  "entity_model_features.config.variation_base.tooltip": "在使用 OptiFine 时，要求为变体提供 '基础' 模型是一种最佳实践，因为这与 OptiFine 的兼容性可能非常不一致。启用此设置后，意味着 'pig2.jem' 在没有 'pig.jem' 的情况下不会进行变体。\nEMF 不要求这一点，但如果在此启用，则会强制执行此操作，以便尽可能保留与 OptiFine 的兼容性。\n你可以通过在 EMF 设置中导出默认模型来轻松获取它，路径为 'models > allmodels > *model* > export'。\n或者只需禁用此设置。",
  "entity_model_features.config.double_chest_fix": "修复双箱模型日志错误",
  "entity_model_features.config.double_chest_fix.tooltip": "因为双箱模型 'chest_large.jem' 必须在代码中分割成两个半模型，\n可能会有大量关于缺失左/右半部分的日志垃圾信息。\n启用此选项后将修复该问题，并在一定程度上修复与箱子对面部分相关的动画。\n你仍然强烈建议将左右半部分的动画分开。\n这是一个选项，因为可能会有其他模组影响箱子模型，导致此问题。",
  "entity_model_features.config.iris_shadow_skip": "跳过动画 Iris 阴影渲染",
  "entity_model_features.config.iris_shadow_skip.tooltip": "这会让实体模型不会在每帧渲染和 Iris 阴影渲染时都进行动画\n这应该始终开启，仅在未来 Iris API 发生变化时才会使用"
}
